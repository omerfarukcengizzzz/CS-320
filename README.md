# CS-320

##1. Ensuring Functionality and Security

To make sure my code is both functional and secure, I focused on thorough testing and best coding practices. Each unit test in my projects was designed to validate individual components, ensuring they behaved as expected and met all requirements. For instance, in the ContactService project, I used JUnit tests to confirm the integrity of each method, like adding and updating contacts, which helped to catch any unexpected errors early. Additionally, I adhered to principles of secure coding by avoiding hardcoded sensitive information and validating inputs, especially with fields like IDs and phone numbers. This approach allowed me to catch potential security vulnerabilities, ensuring that my code remains robust and safe.

##2. Interpreting User Needs and Incorporating Them

Interpreting and incorporating user needs was a key part of the development process. I started by analyzing the project requirements carefully, translating each requirement into concrete features that I could implement. For example, when designing the ContactService, I ensured that each contactâ€™s ID was unique and non-editable, aligning with typical user needs for reliable data management. I used these requirements to shape my approach to testing and functionality, verifying that the final product would satisfy end-user expectations and make the program practical in real-world scenarios. By breaking down each requirement and mapping it to specific actions in my code, I was able to create a project that effectively addressed user needs.

##3. Approach to Software Design

My approach to designing software centers around simplicity, maintainability, and efficiency. I begin with a clear plan, organizing my classes and methods so that each part of the program has a specific, focused purpose. For example, in the AppointmentService project, I designed the classes to handle specific actions related to appointments, such as adding or deleting entries, which made the code easier to read and maintain. Additionally, I followed principles of modular design, allowing individual components to be updated or tested without affecting the entire program. This approach to design helps ensure that the software remains adaptable and manageable as new features or updates are required.
